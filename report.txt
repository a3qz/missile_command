Report
Ryan Michalec and Jessica Cioffi

Quick definitions for reference: The things streaming down from the top of the screen are "missiles".  The things the user launches are "bombs", and the things they are defending are "cities".  

Note on errors running: if you get the error: Major opcode of failed request: 45 (X_OpenFont), it may be necessary to go into the code and comment out the changefonts.  On some machines when sshing in, they do not have access to some of the fonts we chose from the computers in Fitzpatrick.  

From the user's perspective, this is the game Missile Command.  The goal 
of the user is to try to survive as long as they can before the missiles 
coming down from the top of the screen destroy the cities at the bottom 
of the screen as well as to ammass the highest possible score.  In order to stop a missile from going hitting a city and destroying it, the user will click, and an explosion will begin to grow at that point.  If the tip of the missile is in the range of this explosion, it is destroyed, and the user gains 25 points.  If the user allows a missile to hit a city, then that city will be destroyed for the remainder of that game.  A user completes a level when every missile has either been destroyed by the user or has hit the ground/a city.  At the end of each level, the user is awarded bonus points based on how many cities are left.  Unlike the original versions of the game, we do not restrict the number of bombs that the user has, as we thought it would make the game unnecessarily difficult.  In order to pause the game, the user can press escape.  Another press of escape will continue the game, and pressing 1, 2, or 3 will continue the game, start a new game fresh from the beginning, or quit the program entirley, respectivley.  Upon a game over, pressing 1 will start a new game and 2 will quit the game (these are both explained in the corresponding screens as well).  

From the programmers perspective, this program is a series of loops to fuel the animation using functions to do the math checking how to change the gamestate.  Inside one loops is everything that happens inside one level, and there is a loop inside that that controls what happens frame by frame.  Things that do not need to happen more than once, such as the drawing the base and initializing the characteristics of the missiles (speed, direction(which is randomly chosen within the range of the size of the base), location, etc) are done in the outer loop, while things such as computing each new step for the missile and drawing them, animating the bombs, and checking for user input all occur in the inner loop.  The missiles and bombs are stored in arrays of structs.  Missiles are initialized at the beginning of each level and animate over the course of the level based on a vertical and horizontal speed, determined as a function of level inside the initialize function.  Each iteration of the frame loop calculates the next step for each missile and animates it while drawing a line over the previous iteration in order to keep the board clean.  If the user clicks, it initializes an element of the bomb array at that location.  Based on this element, there is a loop that checks the bomb array to see if any bombs should be active.  If it finds any, it adjusts their radius and draws the change, causing the bomb to grow bigger.  It then also scans through the array of missiles to see if there are any whose heads are inside this radius, and if there are any, it turns them off and draws a black line over them to erase, and adjusts the score.  If a pause is ever pressed, the entire game will stop thanks to a looped gfx_wait call, but the game will resume with no change if the continue option is chosen.  Between levels, there is a wait screen that must be clicked on to continue, in order to give the user both a display of their score and some time to breathe between levels.  


In order evaluate if our program was correct, we both tested it extensivley upon completion, as well as played different versions of the game on both an Atrai 2600 remake console as well as a flash based remake online in order to observe how the game typically responded to strange edge cases and how ours compared. We also tested different situations by removing the random element in order to pinpoint specific cases that were giving us trouble, which allowed us to more quickly test out different implementations of solutions.  

